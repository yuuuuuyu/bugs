#  弹窗组件中使用自定义组件
:::tip
有任何相关问题可直接联系 @刘华勋
:::

### 在弹窗组件中引入自定义组件：

蜂舟的自定义组件功能，可以实现等同.vue文件中组件引入的功能。
<drawing-bed src="20240417/image-20240411091752933.png"/>

以弹窗组件引入自定义组件为例：当我们把自定义组件拖入当前组件后，在相应的组件目录下会生成两个一模一样的文件，
<drawing-bed src="20240417/image-20240411091840589.png"/>

不难发现1是在base文件夹下，该文件夹下的所有内容不可编辑。我们编辑的是2内的index.vue文件，该文件夹与base同级，不会被覆盖。

对于文件夹2内的vue文件，我们有两种编辑方式：

1 最常见的方式就是我们在vue文件中直接通过模板和js逻辑编写我们需要的功能组件，该种方式适用于复用性不高或针对性强的组件。

2 如果被引入的组件复用性强，甚至是一个全局组件，那么我们可以通过2下的vue文件引入相应的组件即可：
<drawing-bed src="20240417/image-20240411091853061.png"/>


在此过程中，我们可以通过注入当前组件上下文ctx的方式实现与最外层组件的交互（上图代码第7行），因为inject注入的依赖也是响应式的，所以操作起来与在最外层index.vue相同。整体的思路完全遵循VUE的数据双向流，可灵活变通。

### 自定义组件的进阶使用
1：在任意可拖拽区域使用自定义组件：
在实际运用中，自定义组件默认的宽高均为100%，所以在没有约束的组件内会占据所有空间。在空间较小，又希望使用自定义组件完成订制功能时，可已先将自定义组件样式更改为适当尺寸，再拖拽的相应位置，比如在表格组件中：
<drawing-bed src="20240417/zidingyizujian7.png"/>
<drawing-bed src="20240417/zidingyizujian2.png"/>

2：当前弹窗组件可根据需求设置为全屏或普通弹窗，配合自定义组件可以满足多种交互场景需求。例如：

在蜂舟平台的新建页面模板界面，绿色框内容是自定义组件，表单和弹窗组件主体均为蜂舟平台生成。
<drawing-bed src="20240417/image-20240412142149753.png"/>
<drawing-bed src="20240417/image-20240412142410650.png"/>


<drawing-bed src="20240417/image-20240412142342098.png"/>


自定义组件的逻辑代码尽量都写在自己的vue文件中，方便维护管理。所以尽量避免在继承的类方法中使用自定义组件中的数据或方法


<drawing-bed src="20240417/image-20240412154408845.png"/>


​     上图的代码来自自定义组件，中红框中字段是用来控制页面和按钮的显示：当点击‘下一步’则隐藏自定义组件显示表单，并显示“确定”按钮。这种方式的好处是任何子组件都能共享父组件的数据和方法，且是响应式的数据。缺点是没有了通过props父子传值的数据保护机制，注意子组件要避免意外的改变父组件的值。



  对于蜂舟生成的组件中元素的显示和隐藏，则可通过ctx.compConfig['组件名'].props设置style样式实现。也可参考示例中的方法。

```js
const showContraler = (componentName, flag = false) => {
    const config = ctx.compConfig[componentName]
    if (flag) {
        if (config.props) {
            config.props.style = { display: '' }
        } else {
            config.props = { style: { display: '' } }
        }
    } else {
        if (config.props) {
            config.style = { display: 'none' }
        } else {
            config.props = { style: { display: 'none' } }
        }
    }
}
```

### vue中操作模板dom的思路：

 上述通过ctx中组件对象的配置项的思路更符合前端在vue文件中编写逻辑的习惯。原理上是通过v-bind绑定了 ctx.compConfig[componentName]对应组件配置项props内的属性。我们可以随意编辑这里的属性实现控制元素的目的。

蜂舟生成的vue代码：
<drawing-bed src="20240417/image-20240415153331362.png"/>


ctx的数据结构如下：
<drawing-bed src="20240417/image-20240415153830244.png"/>


​    红框中标注出来的就是当前组件中，所有包含的元素配置项，props下就是该组件v-bind绑定的所有内容，我们可以通过修改这里的配置来实现需要的功能。子集中的元素也是同样道理，因为整个ctx对象都是响应式的，所以方便开发的同时也要注意数据安全性。

   综上，我们通过在ctx.state中添加管理响应式字段，配合compConfig对象中的组件属性配置，就能实现常规的MVVM模型的UI交互逻辑。这种思路可能更类似React的方式，或者用过Antd的小伙伴比较熟悉。

