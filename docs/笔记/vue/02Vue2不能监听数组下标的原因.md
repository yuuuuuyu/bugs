# Vue2不能监听数组下标的原因

### 产生原因
在 Vue 2 中，由于 JavaScript 的限制，Vue 不能检测到数组下标的变化。Vue2使用`Object.defineProperty`劫持对象属性，从而实现数据响应式，当修改或访问属性时触发相应更新。但是这种方法无法检测到数组索引的变化，因为 JavaScript 不允许通过索引来设置属性描述符。

```js
this.arr[0] = 'new value'; // 这种方式不会触发 Vue 的响应式更新
```

### 处理方案

<br>

#### 重写Array的数组方法

```ts
import { TriggerOpTypes } from '../../v3'
import { def } from '../util/index'

const arrayProto = Array.prototype
export const arrayMethods = Object.create(arrayProto)

const methodsToPatch = [
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
]

methodsToPatch.forEach(function (method) {
  // cache original method
  const original = arrayProto[method]
  def(arrayMethods, method, function mutator(...args) {
    const result = original.apply(this, args)
    // !!!!!
    // 获取当前数组关联的 Observer 实例, Observer类在下边
    const ob = this.__ob__
    let inserted
    // push/unshift 和 splice 操作数组后会有元素变化所以使用inserted暂存
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args
        break
      case 'splice':
        inserted = args.slice(2)
        break
    }
    // !!!!!
    // 当inserted不为undefined时，将新元素转换为响应式。
    // 调用 Observer 实例中的 observeArray，代码在下边
    if (inserted) ob.observeArray(inserted)
    // notify change
    if (__DEV__) {
      ob.dep.notify({
        type: TriggerOpTypes.ARRAY_MUTATION,
        target: this,
        key: method
      })
    } else {
      ob.dep.notify()
    }
    return result
  })
})

```

```ts
export class Observer {
  dep: Dep
  vmCount: number // number of vms that have this object as root $data

  constructor(public value: any, public shallow = false, public mock = false) {
    // this.value = value
    this.dep = mock ? mockDep : new Dep()
    this.vmCount = 0
    def(value, '__ob__', this)
    if (isArray(value)) {
      if (!mock) {
        if (hasProto) {
          /* eslint-disable no-proto */
          ;(value as any).__proto__ = arrayMethods
          /* eslint-enable no-proto */
        } else {
          for (let i = 0, l = arrayKeys.length; i < l; i++) {
            const key = arrayKeys[i]
            def(value, key, arrayMethods[key])
          }
        }
      }
      if (!shallow) {
        this.observeArray(value)
      }
    } else {
      const keys = Object.keys(value)
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i]
        defineReactive(value, key, NO_INITIAL_VALUE, undefined, shallow, mock)
      }
    }
  }
  /**
   * Observe a list of Array items.
   */
  observeArray(value: any[]) {
    for (let i = 0, l = value.length; i < l; i++) {
      // !!!!!
      // observe中依旧是new Observer
      observe(value[i], false, this.mock)
    }
  }
}
```
#### 提供set方法
提供了一个全局 API `Vue.set`（或在实例方法中使用 `this.$set`），可以用来向响应式对象中添加新的属性，并确保这个新属性也是响应式的：
```js
Vue.set(this.arr, 0, 'new value'); // 使用 Vue.set 也可以触发响应式更新
```

### vue3的处理

在vue3中响应式系统得到了重写，使用了 `Proxy` 来代替 Vue2 中的 `Object.defineProperty`。使得 Vue3 能够更精确地追踪对象和数组的变化，包括通过索引直接修改数组的能力。

由于 `Proxy` 可以直接监听对象和数组的变化，包括新增和删除属性，因此在 Vue3 中，你可以直接通过索引来修改数组，而无需使用特殊的数组方法或 Vue.set，所以移除了 Vue2 中的全局 API `Vue.set` 和 `Vue.delete`，因为 Proxy 已经提供了这些功能

```js
this.arr[0] = 'new value'; // 在 Vue 3 中，这种方式会触发响应式更新
```


### 扩展Object.defineProperty

在js中，对象属性的访问和修改是通过属性描述符（Property Descriptor）来控制的。Vue2 使用 `Object.defineProperty` 方法来劫持对象的属性，从而实现响应式。这个方法允许你定义属性的特性，如可写性（writable）、可枚举性（enumerable）和可配置性（configurable），以及属性的 getter 和 setter 函数。

但是 `Object.defineProperty` 有一个重要的限制：它只能用于对象的***已有属性***。当你尝试通过索引来设置数组元素时，实际上是在创建一个新的属性，而不是修改一个已有的属性。由于 JavaScript 引擎内部处理数组的方式，通过索引设置数组元素并不会触发 Object.defineProperty 设置的 setter 函数。代码如下：

```js
const a = [1, 2, 3, 4, 5]

Object.keys(a).forEach(k => {
    Object.defineProperty(a, k, {
        get: function () {
            console.log(`key: ${k}`)
        },
        set: function (value) {
            console.log(`触发set: ${value}`)
        },
        enumerable: true,
        writable: true,
        configurable: true
    })
})

a[3] = 44 // 触发
a[5] = 6  // 不触发
```